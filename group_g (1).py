# -*- coding: utf-8 -*-
"""Group_G.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_CU1cNb4UktI2-cAffxzjrDQ21JatzW-

# **Overview of the MTA Dataset Visualization Project**

The dataset we chose is released by the Metropolitan Transportation Authority (MTA) and provides one of the most detailed views of vehicular traffic flows into the Manhattan Congestion Relief Zone (CRZ), which was created by NYC's congestion pricing policy and includes areas under 60th Street in Manhattan. The dataset was created on *Jan 5th, 2025*, which was the implementation date of the policy. It includes *tolling-related detection data, capturing where, when, and what types of vehicles are entering key areas*. This dataset supports analysis around traffic volume, vehicle characteristics, and roadway usage patterns to better understand the effectiveness and impacts of the newly implemented congestion pricing policy.

# **Purpose of This Visualization Project:**

The purpose of this visualization project is to help understand the patterns of vehicle entries into the Congestion Relief Zone and related roadways, providing insights into:

1. Distribution of Vehicle Entry Points into Manhattan

2. Traffic distribution across entry points

3. Vehicle type composition

4. Temporal patterns (by hour, day, peak/non-peak periods)


The analysis would be insightful for:

1. Traffic management

2. Policy decisions (congestion pricing policy and further adjustments to the policy)

3. Public understanding of congestion patterns and the effectivenss of the policy

4. Supporting data-driven infrastructure planning

The dataset has been limited to include data from Jan 5th to Feb 5th, 2025, which is the first month of policy implementation, to understand the short-term/immediate effect of the policy.

# **Intended Exploratory Visualization Tasks and Variables Involved:**

1. Word Cloud of Detection Group:	Detection Group

2. Entry Points and Number/Percentage of Entries:

3. Number of Entries vs. Vehicle Types:

4. Number of Entries by Time (Hour, Peak, Day of Week):

5. Congestion Relief Zone vs. Excluded Roadway Entries:
"""

import pandas as pd
import numpy as np
from google.colab import files
uploaded = files.upload()

df=pd.read_csv('MTA_Entries.csv')

df['Toll Hour'] = pd.to_datetime(df['Toll Hour'], format='%m/%d/%Y %I:%M:%S %p')
cutoff_date = pd.to_datetime('2025-02-05 12:59:59')
df = df[df['Toll Hour'] <= cutoff_date]
df

"""### **1. Word Cloud for Detection Group**
The Detection Group word cloud visualizes the distribution of vehicle entry points into Manhattan at or below 60th Street. Each Detection Group represents a specific crossing location where vehicles are detected as they first enter the area (e.g., Lincoln Tunnel, Williamsburg Bridge, Manhattan Bridge).


**Rationale Behind Chosen Visualization Tool**:

By presenting these entry points in a word cloud, where larger words represent crossings with higher entry volumes and smaller words indicate crossings with fewer detected entries, We can easily identify the most frequently used entry routes into the congestion zone and understand the spatial distribution of traffic inflows.
"""

from wordcloud import WordCloud
import matplotlib.pyplot as plt

# Count frequencies of each Detection Group
detection_group_counts = df["Detection Group"].value_counts()

# Generate word cloud
def generate_wordcloud():
    wordcloud = WordCloud(width=800, height=400, max_words=100, colormap="Blues").generate_from_frequencies(
        detection_group_counts.to_dict()
    )

    # Display word cloud
    plt.figure(figsize=(10, 5))
    plt.imshow(wordcloud, interpolation="bilinear")
    plt.axis("off")
    plt.title("Word Cloud for Detection Group", fontsize=14)
    plt.show()

generate_wordcloud()

"""**Interpretation**: As shown above, notable high-traffic entry points include the Brooklyn Bridge, Queensboro Bridge, and East 60th St, suggesting these locations as key access routes into Manhattan. Other significant entry points include major tunnels like the Lincoln Tunnel and Hugh L. Carey Tunnel, as well as bridges like the Williamsburg Bridge and Manhattan Bridge. With these information, policy makers can identify high-traffic entry points and make informed decisions on traffic flow optimization, signal adjustments, and lane management at key congestion hotspots.

### **2.Entry Points and Number/Percentage of Entries**

**2.1 Entry Points on map**

Now that we can identify high-traffic entry points, we want to visualize how much traffic is distributed across various entry points into Manhattan. A map of Manhattan with heat maps wil then be made to indicate traffic volumes at different entry points. This graph can highlight the most congested areas and show spatial patterns in vehicle entries by presenting entry points with different colors, with deep red indicating higher traffic volumn.
"""

import folium
from folium.plugins import HeatMap
import pandas as pd

entry_points = {
    'Brooklyn Bridge': {'lat': 40.70563, 'lon': -73.99635},
    'Queensboro Bridge': {'lat': 40.759, 'lon': -73.955},
    'East 60th St': {'lat': 40.76305, 'lon': -73.96818},
    'Manhattan Bridge': {'lat': 40.7075, 'lon': -73.99077},
    'Lincoln Tunnel': {'lat': 40.760128, 'lon': -74.003065},
    'West Side Highway at 60th St': {'lat': 40.7714, 'lon': -73.9905},
    'Queens Midtown Tunnel': {'lat': 40.7407, 'lon': -73.9588},
    'Williamsburg Bridge': {'lat': 40.71369, 'lon': -73.97262},
    'Holland Tunnel': {'lat': 40.727399, 'lon': -74.021338},
    'Hugh L. Carey Tunnel': {'lat': 40.6958, 'lon': -74.0136},
}

# Grouping data by Detection Group to sum traffic volume (CRZ Entries)
entry_data = df.groupby('Detection Group')['CRZ Entries'].sum().reset_index()

# Add latitude and longitude for each entry point based on the manual dictionary
entry_data['lat'] = entry_data['Detection Group'].map(lambda x: entry_points.get(x, {}).get('lat'))
entry_data['lon'] = entry_data['Detection Group'].map(lambda x: entry_points.get(x, {}).get('lon'))

# Filter out rows where lat/lon are missing (if any)
entry_data = entry_data.dropna(subset=['lat', 'lon'])

# Create a map centered around Manhattan
map_manhattan = folium.Map(location=[40.758, -73.985], zoom_start=12)

# Prepare data for the heatmap
heat_data = [[row['lat'], row['lon'], row['CRZ Entries']] for index, row in entry_data.iterrows()]

# Add HeatMap layer
HeatMap(heat_data).add_to(map_manhattan)

map_manhattan

"""The size of the heatmap above intensifies based on the traffic volume at each location, highlighting key areas of high congestion such as the **Brooklyn Bridge**, **Queensboro Bridge**, and **Manhattan Bridge**. This pattern reflects the most used entry points during the time period of interest.

However, for individuals who may not be familiar with Manhattan, the specific entry points may be hard to identify. To improve clarity, we decide to add labels andf markers indicating the names of these entry points below each heatmap location.
"""

# Create a new map centered around Manhattan
map_manhattan_with_labels = folium.Map(location=[40.758, -73.985], zoom_start=12)

# Add the HeatMap layer
HeatMap(heat_data).add_to(map_manhattan_with_labels)

# Add labels with entry point names below each point
for index, row in entry_data.iterrows():
    html = f"""
        <b>Entry Point:</b> {row['Detection Group']}<br>
        <b>Number of Entries:</b> {row['CRZ Entries']}
    </div>
    """

    popup = folium.Popup(html, max_width=200)

    folium.Marker(
        location=[row['lat'], row['lon']],
        popup=popup,
        icon=folium.Icon(color='blue', icon='info-sign')
    ).add_to(map_manhattan_with_labels)

map_manhattan_with_labels

import branca.colormap as cm

map_manhattan_with_bubbles = folium.Map(location=[40.758, -73.985], zoom_start=12)

min_entries = min(entry_data['CRZ Entries'])
max_entries = max(entry_data['CRZ Entries'])

colormap = cm.LinearColormap(
    colors=['blue', 'purple', 'orange', 'red'],
    vmin=min_entries,
    vmax=max_entries,
)

map_manhattan_with_bubbles.add_child(colormap)

for index, row in entry_data.iterrows():
    html = f"""
    <div style="font-family: Arial, sans-serif; padding: 5px;">
        <b>Entry Point:</b> {row['Detection Group']}<br>
        <b>Number of Entries:</b> {row['CRZ Entries']}
    </div>
    """

    radius = int(np.sqrt(row['CRZ Entries']) / 35)
    circle_color = colormap(row['CRZ Entries'])

    folium.CircleMarker(
        location=[row['lat'], row['lon']],
        radius=radius,
        popup=folium.Popup(html, max_width=200),
        tooltip=f"{row['Detection Group']} | Entries: {row['CRZ Entries']}",
        color=circle_color,
        fill=True,
        fill_color=circle_color,
        fill_opacity=0.6,
        weight=1
    ).add_to(map_manhattan_with_bubbles)

map_manhattan_with_bubbles

"""East 60th Street clearly has more entries compared to other detection points, which might be because the income level of Upper East Side is generally higher and people are not switching to other commuting methods like public transit as a reaction to the additional toll of congestion pricing. On the other hand, since there are several entry points for Queens, Brooklyn, and New Jersey, it can also because the entries in other areas are more separated. Therefore, we will look at the entries based on detection region next.

## **2.2 Number/Percentage of Entries**

Now that we got the map, we will then create a table that shows the percentage of entries for different regions based on the Detection Region (e.g., Brooklyn, Queens, New Jersey).
"""

# Calculate the total entries and the percentage of entries for each Detection Region
region_data = df.groupby('Detection Region')['CRZ Entries'].sum().reset_index()

# Calculate the total traffic volume to compute percentages
total_entries = region_data['CRZ Entries'].sum()

# Calculate percentage for each region
region_data['Percentage'] = (region_data['CRZ Entries'] / total_entries) * 100
region_data['Percentage'] = region_data['Percentage'].round(0)

region_data = region_data.sort_values(by='Percentage', ascending=False)

region_data

styled_table = region_data.style.set_table_styles([
    {'selector': 'thead th', 'props': [('background-color', '#0074CC'), ('color', 'white'), ('font-weight', 'bold')]},
    {'selector': 'tbody td', 'props': [('text-align', 'center'), ('padding', '10px'), ('background-color', '#f9f9f9')]},
    {'selector': 'tbody tr:nth-child(even)', 'props': [('background-color', '#f1f1f1')]},
    {'selector': 'tr:hover', 'props': [('background-color', '#ddd')]},
    {'selector': 'caption', 'props': [('font-size', '1.5em'), ('margin-bottom', '10px'), ('text-align', 'center')]}
])

styled_table

"""And here is an interactive bar chart using **Plotly**"""

import matplotlib.pyplot as plt
import plotly.express as px

data = {
    'Detection Region': ['Brooklyn', 'New Jersey', 'East 60th St', 'Queens', 'FDR Drive', 'West Side Highway', 'West 60th St'],
    'CRZ Entries': [3605882, 2528373, 2384941, 2323184, 1567205, 1281788, 1202162],
    'Percentage': [24, 17, 16, 16, 11, 9, 8]
}

df_interactive = pd.DataFrame(data)

fig = px.bar(df_interactive,
             x='Detection Region',
             y='Percentage',
             #text='Percentage',
             color='Detection Region',
             #color_discrete_sequence=['#0074CC'],  # MTA Blue color
             title='Percentage of CRZ Entries by Detection Region')

#fig.update_traces(texttemplate='%{text}%', textposition='outside', marker=dict(line=dict(color='black', width=1)))
fig.update_layout(
    title=dict(y=0.9, x=0.45, xanchor="center", yanchor="top"),
    width=1200,
    height=600,
    xaxis_title='Detection Region',
    yaxis_title='Percentage of Entries (%)',
    template='simple_white',
    font=dict(family="Arial", size=14, color="black")
)

"""Whlie East 60th Street has the most entries when looking at the specific detection point, it is not grouped into a larger region like Brooklyn that has several entry points into Manhattan, but the percentage of 17% is still pretty high with it acting as an individual region itself.

### **3. Number of Entries vs. Vehicle Types**

To represent the distribution of vehicles by category in the tolling system, a bar chart can be used. The chart will display the average daily number of entries by vehicle types.
"""

daily_avg = df.groupby(['Toll Date', 'Vehicle Class'])['CRZ Entries'].sum().reset_index()
daily_avg = daily_avg.groupby('Vehicle Class')['CRZ Entries'].mean().reset_index(name='Average Daily Count')
daily_avg_sorted = daily_avg.sort_values('Average Daily Count', ascending=False)

vehicle_chart = px.bar(
    daily_avg_sorted,
    x='Vehicle Class',
    y='Average Daily Count',
    color='Vehicle Class',
    title='Average Daily Number of Entries by Vehicle Type'
)

vehicle_chart.update_layout(
    title=dict(y=0.9, x=0.45, xanchor="center", yanchor="top"),
    yaxis_type="log",
    yaxis_title="Count of Entries (log scale)",
    template='simple_white',
    font=dict(family="Arial", size=14, color="black"),
    width=1200,
    height=600,
    xaxis_title='Vehicle Class',
    yaxis=dict(
        type="log",
        title="Count of Entries (log scale)",
        tickformat=",",
        tickvals=[1, 10, 100, 1000, 10000, 100000],
        ticktext=["1", "10", "100", "1,000", "10,000", "100,000"]
    )
)

vehicle_chart.show()

"""## **4. Number of entries by time**

The congestion pricing policy sets the charing peak hour to 5 a.m. to 9 p.m. on weekdays and 9 a.m. to 9 p.m. on weekends, with the rest as off-peak/overnight hours. As the policy is primary targeting at peak hours with a higher toll rate of 9 dollars and off-peak hour toll is 2.25 dollars, we were expecting the peak-hour entries to reduce over time after the policy implementation. However, the graphs show relatively stable trends over time, with weekday peaks having lower entries and weekend peaks having higher.
"""

daily_avg_detection = df.groupby(['Toll Date', 'Time Period', 'Detection Group'])['CRZ Entries'].sum().reset_index()
daily_avg_detection = daily_avg_detection.groupby(['Time Period', 'Detection Group'])['CRZ Entries'].mean().reset_index()
daily_avg_detection = daily_avg_detection.sort_values(by='CRZ Entries', ascending=True)
pivot = daily_avg_detection.pivot(index='Detection Group', columns='Time Period', values='CRZ Entries').reset_index()
pivot = pivot.sort_values(by='Peak', ascending=False)
sorted_detection_groups = pivot['Detection Group'].tolist()

detection_time_chart = px.bar(
    daily_avg_detection,
    x='CRZ Entries',
    y='Detection Group',
    color='Time Period',
    barmode='group',
    orientation='h',
    title='Average Daily Entries by Detection Group and Time Period',
    labels={'CRZ Entries': 'Count of Entries'},
    category_orders={'Detection Group': sorted_detection_groups,'Time Period': ['Overnight', 'Peak']}
)

detection_time_chart.update_layout(
    title=dict(y=0.9, x=0.55, xanchor="center", yanchor="top"),
    xaxis_title="",
    yaxis_title="",
    template='simple_white',
    font=dict(family="Arial", size=14, color="black"),
    width=1000,
    height=600
)

detection_time_chart.show()

dow_avg = df.groupby(['Toll Date', 'Day of Week', 'Time Period'])['CRZ Entries'].sum().reset_index()
dow_avg = dow_avg.groupby(['Day of Week', 'Time Period'])['CRZ Entries'].mean().reset_index()
dow_avg = dow_avg.sort_values(['Day of Week', 'Time Period'])

dow_chart = px.bar(
    dow_avg,
    x='Day of Week',
    y='CRZ Entries',
    color='Time Period',
    barmode='group',
    title='Average Daily Entries by Day of Week and Time Period',
    labels={'CRZ Entries': 'Average Daily Entries', 'Day of Week': 'Day of Week'},
    category_orders={'Day of Week': ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
                     'Time Period': ['Peak', 'Overnight']},
    color_discrete_sequence=['#EF553B', '#636EFA']
)

dow_chart.update_layout(
    title=dict(y=0.9, x=0.45, xanchor="center", yanchor="top"),
    template='simple_white',
    font=dict(family="Arial", size=14, color="black"),
    width=1000,
    height=600,
    legend_title="Time Period"
)

dow_chart.show()

daily_totals = df.groupby(['Toll Date','Day of Week', 'Time Period'])['CRZ Entries'].sum().reset_index()
daily_total = daily_totals.groupby(['Toll Date', 'Day of Week', 'Time Period'])['CRZ Entries'].mean().reset_index()
daily_total['Toll Date'] = pd.to_datetime(daily_total['Toll Date'])

time_chart = px.line(
    daily_total,
    x='Toll Date',
    y='CRZ Entries',
    color='Time Period',
    title='Average Daily Entries Over Time',
    labels={'CRZ Entries': 'Total Daily Entries', 'Toll Date': 'Date'},
    color_discrete_map={
        'Peak': '#EF553B',
        'Overnight': '#636EFA'
    }
)

time_chart.update_layout(
    title=dict(y=0.9, x=0.45, xanchor="center", yanchor="top"),
    template='simple_white',
    font=dict(family="Arial", size=14, color="black"),
    width=1000,
    height=500,
    legend_title="Time Period"
)

time_chart.update_xaxes(
    tickmode='auto',
    nticks=13,
    tickformat='%m-%d'
)

weekend_dates = daily_total[daily_total['Day of Week'].isin(['Saturday', 'Sunday'])]['Toll Date'].unique()
for date in weekend_dates:
    date = pd.to_datetime(date)
    next_date = date + pd.Timedelta(days=1)
    time_chart.add_shape(
        type="rect",
        x0=date,
        x1=next_date,
        y0=0,
        y1=1,
        yref="paper",
        fillcolor="lightgray",
        opacity=0.3,
        layer="below",
        line_width=0,
    )

time_chart.add_annotation(
    xref="paper",
    yref="paper",
    x=0.02,
    y=0.02,
    text="Gray areas indicate weekends",
    showarrow=False,
    font=dict(
        family="Arial",
        size=12,
        color="black"
    ),
    bgcolor="white",
    borderwidth=1,
    borderpad=4,
    opacity=0.8
)

time_chart.update_traces(mode='lines+markers', marker=dict(size=6))


time_chart.show()

"""How about by time of the day?"""

df['Toll Date'] = pd.to_datetime(df['Toll Date'], errors='coerce')
df['Toll Hour'] = pd.to_datetime(df['Toll Hour'], format='%m/%d/%Y %I:%M:%S %p', errors='coerce')

# Create a new column for just the time portion (hour and minute)
df['Time'] = df['Toll Hour'].dt.strftime('%H:%M')

# First verify we have data
print(df['Time'].head())
print(df['CRZ Entries'].head())

# Group by time and calculate average entries
time_sums = df.groupby(['Toll Date', 'Time'])['CRZ Entries'].sum().reset_index()
df_avg_entries = time_sums.groupby('Time')['CRZ Entries'].mean().reset_index()

# Sort by time to ensure proper ordering
df_avg_entries['Time'] = pd.to_datetime(df_avg_entries['Time'], format='%H:%M').dt.strftime('%H:%M')
df_avg_entries = df_avg_entries.sort_values('Time')

# Create an interactive line chart with Plotly
fig = px.line(df_avg_entries,
              x='Time',
              y='CRZ Entries',
              title='CRZ Entries by Time of Day (10-minute increments)',
              labels={'Time of Day': 'Time of Day (10-minute increments)', 'CRZ Entries': 'Average CRZ Entries'},
              line_shape='linear')

# Add shaded areas for morning and evening commute times
fig.add_vrect(x0="06:00", x1="10:00", fillcolor="lightblue", opacity=0.3, line_width=0,
              annotation_text="Morning Commute Hours", annotation_position="top left")
fig.add_vrect(x0="16:00", x1="20:00", fillcolor="lightblue", opacity=0.3, line_width=0,
              annotation_text="Evening Commute Hours", annotation_position="top left")

# Customize the layout for interactivity
fig.update_layout(
    template='simple_white',
    title=dict(y=0.9, x=0.45, xanchor="center", yanchor="top"),
    xaxis_title='Time of Day (10-minute increments)',
    yaxis_title='Average CRZ Entries',
    font=dict(family="Arial", size=14, color="black"),
    xaxis=dict(tickmode='linear', tick0=0, dtick=1),
    width=1200,
    height=600,
    hovermode="x unified"  # Show hover information for each x-axis value
)

# Show the interactive chart
fig.show()

"""The line chart illustrates the average CRZ entries by time of day in 10-minute increments, showing clear peaks during morning (6 AM - 10 AM) and evening (4 PM - 8 PM) commute hours. These periods reflect high traffic volumes, likely due to daily commuting patterns. The early morning hours (12 AM - 3 AM) see lower traffic, gradually increasing until reaching peak entry volumes during rush hours.

### **5. Congestion Relief Zone vs. Excluded Roadway Entries**

Excluded Roadway Entries refer to trips solely on the FDR Drive, the West Side Highway, and/or any surface roadway portion of the Hugh L. Carey Tunnel connecting to West Street (the “Excluded Roadways”) entering at the specified detection group.

By comparing CRZ entries with Excluded Roadway entries, we can gain insights into:

1. Traffic distribution: How much traffic is entering the Congestion Relief Zone versus using alternate roadways.

2. Effectiveness of the congestion pricing policy: Whether vehicles are opting for toll-free routes to bypass the CRZ or whether the pricing is influencing their behavior in terms of entry points.

3. Congestion management: Understanding where traffic congestion is being concentrated and whether the excluded roadways are seeing more traffic as a result of the tolling policy.
"""

# Filter data for Jan 5 - Jan 25, 2025
df_filtered = df[(df['Toll Date'] >= '2025-01-05') & (df['Toll Date'] <= '2025-01-25')]

# Group by 'Toll Date' and sum up the CRZ and Excluded Roadway entries
daily_entries = df_filtered.groupby('Toll Date')[['CRZ Entries', 'Excluded Roadway Entries']].sum().reset_index()

fig = px.bar(daily_entries,
             x='Toll Date',
             y=['CRZ Entries', 'Excluded Roadway Entries'],
             title='Daily Entries to CRZ and Excluded Roadways (Jan 5 - Jan 25)',
             labels={'Toll Date': 'Date', 'value': 'Daily Entries', 'variable': 'Entry Type'},
             color_discrete_sequence=['#0074CC', '#C1D3F7'])

# Customize the layout for interactive features
fig.update_layout(
    barmode='stack',  # Stack the bars
    xaxis_title='Date',
    yaxis_title='Daily Entries',
    template='simple_white',
    width=1200,
    height=600,
    title=dict(y=0.9, x=0.45, xanchor="center", yanchor="top"),
    yaxis=dict(tickmode='array', tickvals=[0, 200000, 400000, 600000]),  # Customize y-axis ticks
    font=dict(family="Arial", size=14, color="black")
)

# Show the interactive chart
fig.show()

"""On Jan 5, 2025, when the program launched, how much did the CRZ Entries make up of the total entries?"""

# Calculate the total entries for each day (CRZ + Excluded Roadway)
daily_entries['Total Entries'] = daily_entries['CRZ Entries'] + daily_entries['Excluded Roadway Entries']

# Calculate the percentage of CRZ Entries for each day
daily_entries['CRZ Percentage'] = (daily_entries['CRZ Entries'] / daily_entries['Total Entries']) * 100

# Show the results
daily_entries[['Toll Date', 'CRZ Entries', 'Excluded Roadway Entries', 'Total Entries', 'CRZ Percentage']]
daily_entries. head()

"""Based on the calculation, the CRZ Entries make up 88.06% of the total entries."""

# Ensure the dataset includes the necessary columns for analysis
df_crossing_points = df[['Toll Date', 'Detection Group', 'CRZ Entries', 'Excluded Roadway Entries']]

# Convert the 'Toll Date' column to datetime and filter for weekdays (Monday to Friday)
df_crossing_points['Toll Date'] = pd.to_datetime(df_crossing_points['Toll Date'])
df_crossing_points['Weekday'] = df_crossing_points['Toll Date'].dt.weekday  # 0: Monday, 6: Sunday

import seaborn as sns

# Filter data for weekdays (Monday to Friday)
df_weekdays_box = df_crossing_points[df_crossing_points['Weekday'] < 5]

# Group by 'Detection Group' (crossing points) and prepare data for boxplot
df_weekdays_box_melted = pd.melt(df_weekdays_box, id_vars=['Detection Group'], value_vars=['CRZ Entries', 'Excluded Roadway Entries'],
                                 var_name='Entry Type', value_name='Entries')

fig = px.bar(avg_entries_by_crossing,
             x='Detection Group',
             y=['CRZ Entries', 'Excluded Roadway Entries'],
             title='Average Weekday Vehicle Entries to CRZ and Excluded Roadways by Crossing Point',
             labels={'Detection Group': 'Crossing Point', 'value': 'Average Vehicle Entries', 'variable': 'Entry Type'},
             color_discrete_sequence=['#0074CC', '#C1D3F7'])

# Customize the layout for interactivity
fig.update_layout(
    barmode='stack',
    xaxis_title='Crossing Point',
    yaxis_title='Average Vehicle Entries',
    font=dict(family="Arial", size=14, color="black"),
    hovermode="x unified"
)

# Show the interactive chart
fig.show()

"""DFR Drive and East 60th St are the top entry points, with CRZ entries significantly higher than Excluded Roadway entries. This suggests that these locations have a higher concentration of traffic entering the CRZ area. Besides, excluded Roadway entries are visible at some locations, but they tend to be secondary routes or alternate entries compared to the CRZ."""

# Ensure we have the necessary columns (Vehicle Class, CRZ Entries, Excluded Roadway Entries)
df_vehicle_category = df[['Toll Date', 'Vehicle Class', 'CRZ Entries', 'Excluded Roadway Entries']]

# Convert the 'Toll Date' column to datetime and filter for weekdays (Monday to Friday)
df_vehicle_category['Toll Date'] = pd.to_datetime(df_vehicle_category['Toll Date'])
df_vehicle_category['Weekday'] = df_vehicle_category['Toll Date'].dt.weekday  # 0: Monday, 6: Sunday

# Filter for weekdays (Monday to Friday)
df_weekdays_vehicle_category = df_vehicle_category[df_vehicle_category['Weekday'] < 5]

# Group by 'Vehicle Class' and calculate the total CRZ and Excluded Roadway entries for each category on weekdays
weekday_entries_by_category = df_weekdays_vehicle_category.groupby('Vehicle Class')[['CRZ Entries', 'Excluded Roadway Entries']].sum().reset_index()

# Create an interactive bar chart with Plotly to compare CRZ vs Excluded Roadway entries by Vehicle Category
fig = px.bar(weekday_entries_by_category,
             x='Vehicle Class',
             y=['CRZ Entries', 'Excluded Roadway Entries'],
             title='Weekday CRZ vs. Excluded Roadway Entries by Vehicle Category',
             labels={'Vehicle Class': 'Vehicle Category', 'value': 'Total Entries', 'variable': 'Entry Type'},
             color_discrete_sequence=['#0074CC', '#C1D3F7'])

# Customize the layout for interactivity
fig.update_layout(
    barmode='group',
    xaxis_title='Vehicle Category',
    yaxis_title='Total Entries',
    font=dict(family="Arial", size=14, color="black"),
    hovermode="x unified"
)

fig.show()

# Install Plotly Dash in Colab
!pip install dash
!pip install dash-html-components
!pip install dash-core-components

import dash
import dash_core_components as dcc
import dash_html_components as html
import plotly.express as px
import pandas as pd
from dash.dependencies import Input, Output

# Prepare the data (Ensure it's in the correct datetime format)
df['Toll Date'] = pd.to_datetime(df['Toll Date'])
df['Toll Hour'] = pd.to_datetime(df['Toll Hour'], format='%m/%d/%Y %I:%M:%S %p')

# Create the app
app = dash.Dash(__name__)

# Layout for the dashboard
app.layout = html.Div([
    # Title of the dashboard
    html.H1("Vehicle Entries to CRZ and Excluded Roadways", style={'text-align': 'center'}),

    # Dropdown for selecting Date Range
    dcc.DatePickerRange(
        id='date-picker-range',
        start_date='2025-01-05',
        end_date='2025-01-25',
        display_format='YYYY-MM-DD',
        style={'width': '50%', 'margin': 'auto'}
    ),

    # Dropdown for selecting Vehicle Class
    dcc.Dropdown(
        id='vehicle-class-dropdown',
        options=[
            {'label': 'All', 'value': 'All'},
            {'label': 'Class 1 (Cars)', 'value': 'Class 1'},
            {'label': 'Class 2 (Small Trucks)', 'value': 'Class 2'},
            {'label': 'Class 3 (Large Trucks)', 'value': 'Class 3'},
            {'label': 'Class 4 (Buses)', 'value': 'Class 4'},
            {'label': 'Class 5 (Motorcycles)', 'value': 'Class 5'},
            {'label': 'TLC Taxis/FHVs', 'value': 'TLC Taxis/FHVs'},
        ],
        value='All',
        style={'width': '50%', 'margin': 'auto'}
    ),

    # Dropdown for selecting Entry Type
    dcc.Dropdown(
        id='entry-type-dropdown',
        options=[
            {'label': 'CRZ', 'value': 'CRZ'},
            {'label': 'Excluded Roadway', 'value': 'Excluded Roadway'}
        ],
        value='CRZ',
        style={'width': '50%', 'margin': 'auto'}
    ),

    # Graph for showing the hourly entries (interactive)
    dcc.Graph(id='entry-graph')
])

# Callback to update graph based on dropdown inputs
@app.callback(
    Output('entry-graph', 'figure'),
    [Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('vehicle-class-dropdown', 'value'),
     Input('entry-type-dropdown', 'value')]
)
def update_graph(start_date, end_date, vehicle_class, entry_type):
    # Filter data based on the selected date range
    filtered_df = df[(df['Toll Date'] >= start_date) & (df['Toll Date'] <= end_date)]

    # Filter based on vehicle class
    if vehicle_class != 'All':
        filtered_df = filtered_df[filtered_df['Vehicle Class'] == vehicle_class]

    # Create the chart based on the selected Entry Type (CRZ or Excluded Roadway)
    if entry_type == 'CRZ':
        fig = px.line(filtered_df,
                      x=filtered_df['Toll Hour'],
                      y='CRZ Entries',
                      title=f'Hourly {entry_type} Entries (Selected Date Range)',
                      labels={'Toll Hour': 'Hour of Day', 'CRZ Entries': 'Total CRZ Entries'})
    else:
        fig = px.line(filtered_df,
                      x=filtered_df['Toll Hour'],
                      y='Excluded Roadway Entries',
                      title=f'Hourly {entry_type} Entries (Selected Date Range)',
                      labels={'Toll Hour': 'Hour of Day', 'Excluded Roadway Entries': 'Total Excluded Roadway Entries'})

    return fig

if __name__ == '__main__':
    app.run(debug=True, use_reloader=False)  # Disable reloader for Colab

